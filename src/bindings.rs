/* automatically generated by rust-bindgen 0.72.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize)
        };
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize)
        };
        unsafe { *byte = Self::change_bit(*byte, index, val) };
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if unsafe { Self::raw_get_bit(this, i + bit_offset) } {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            unsafe { Self::raw_set_bit(this, index + bit_offset, val_bit_is_set) };
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &[u8; 6] = b"4.4.0\0";
pub const __NEWLIB__: u32 = 4;
pub const __NEWLIB_MINOR__: u32 = 4;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 202405;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 202405;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &[u8; 3] = b"hh\0";
pub const __INT16: &[u8; 2] = b"h\0";
pub const __INT64: &[u8; 3] = b"ll\0";
pub const __FAST8: &[u8; 3] = b"hh\0";
pub const __FAST16: &[u8; 2] = b"h\0";
pub const __FAST64: &[u8; 3] = b"ll\0";
pub const __LEAST8: &[u8; 3] = b"hh\0";
pub const __LEAST16: &[u8; 2] = b"h\0";
pub const __LEAST64: &[u8; 3] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const __NEWLIB_H__: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _HAVE_INITFINI_ARRAY: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _LDBL_EQ_DBL: u32 = 1;
pub const _MB_CAPABLE: u32 = 1;
pub const _MB_LEN_MAX: u32 = 8;
pub const _REENT_CHECK_VERIFY: u32 = 1;
pub const _RETARGETABLE_LOCKING: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_REGISTER_FINI: u32 = 1;
pub const _WANT_USE_GDTOA: u32 = 1;
pub const _WIDE_ORIENT: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 1;
pub const __OBSOLETE_MATH: u32 = 1;
pub const __RAND_MAX: u32 = 2147483647;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SORD: u32 = 8192;
pub const __SL64: u32 = 32768;
pub const __SNLK: u32 = 1;
pub const __SWID: u32 = 8192;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const EOF: i32 = -1;
pub const BUFSIZ: u32 = 1024;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const L_tmpnam: u32 = 1024;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const TMP_MAX: u32 = 26;
pub const L_ctermid: u32 = 16;
pub const TINYPRINTF_DEFINE_TFP_PRINTF: u32 = 1;
pub const TINYPRINTF_DEFINE_TFP_SPRINTF: u32 = 1;
pub const TINYPRINTF_OVERRIDE_LIBC: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _LITTLE_ENDIAN: u32 = 1234;
pub const _BIG_ENDIAN: u32 = 4321;
pub const _PDP_ENDIAN: u32 = 3412;
pub const _BYTE_ORDER: u32 = 1234;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const FD_SETSIZE: u32 = 64;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const PTHREAD_SCOPE_PROCESS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CREATE_DETACHED: u32 = 0;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const OBJH_READ: u32 = 0;
pub const OBJH_WRITE: u32 = 1;
pub const OTYPE_DOMAIN: u32 = 2;
pub const OTYPE_DEFTYPE: u32 = 5;
pub const OTYPE_DEFSTRUCT: u32 = 6;
pub const OTYPE_VAR: u32 = 7;
pub const OTYPE_ARRAY: u32 = 8;
pub const OTYPE_RECORD: u32 = 9;
pub const DTYPE_BOOLEAN: u32 = 1;
pub const DTYPE_INTEGER8: u32 = 2;
pub const DTYPE_INTEGER16: u32 = 3;
pub const DTYPE_INTEGER32: u32 = 4;
pub const DTYPE_UNSIGNED8: u32 = 5;
pub const DTYPE_UNSIGNED16: u32 = 6;
pub const DTYPE_UNSIGNED32: u32 = 7;
pub const DTYPE_REAL32: u32 = 8;
pub const DTYPE_VISIBLE_STRING: u32 = 9;
pub const DTYPE_OCTET_STRING: u32 = 10;
pub const DTYPE_UNICODE_STRING: u32 = 11;
pub const DTYPE_INTEGER24: u32 = 16;
pub const DTYPE_UNSIGNED24: u32 = 22;
pub const DTYPE_INTEGER64: u32 = 21;
pub const DTYPE_UNSIGNED64: u32 = 27;
pub const DTYPE_REAL64: u32 = 17;
pub const DTYPE_PDO_MAPPING: u32 = 33;
pub const DTYPE_IDENTITY: u32 = 35;
pub const DTYPE_BITARR8: u32 = 45;
pub const DTYPE_BITARR16: u32 = 46;
pub const DTYPE_BITARR32: u32 = 47;
pub const DTYPE_BIT1: u32 = 48;
pub const DTYPE_BIT2: u32 = 49;
pub const DTYPE_BIT3: u32 = 50;
pub const DTYPE_BIT4: u32 = 51;
pub const DTYPE_BIT5: u32 = 52;
pub const DTYPE_BIT6: u32 = 53;
pub const DTYPE_BIT7: u32 = 54;
pub const DTYPE_BIT8: u32 = 55;
pub const DTYPE_ARRAY_OF_INT: u32 = 608;
pub const DTYPE_ARRAY_OF_SINT: u32 = 609;
pub const DTYPE_ARRAY_OF_DINT: u32 = 610;
pub const DTYPE_ARRAY_OF_UDINT: u32 = 611;
pub const ATYPE_Rpre: u32 = 1;
pub const ATYPE_Rsafe: u32 = 2;
pub const ATYPE_Rop: u32 = 4;
pub const ATYPE_Wpre: u32 = 8;
pub const ATYPE_Wsafe: u32 = 16;
pub const ATYPE_Wop: u32 = 32;
pub const ATYPE_RXPDO: u32 = 64;
pub const ATYPE_TXPDO: u32 = 128;
pub const ATYPE_RO: u32 = 7;
pub const ATYPE_WO: u32 = 56;
pub const ATYPE_RW: u32 = 63;
pub const ATYPE_RWpre: u32 = 15;
pub const TX_PDO_OBJIDX: u32 = 7187;
pub const RX_PDO_OBJIDX: u32 = 7186;
pub const COMPLETE_ACCESS_FLAG: u32 = 32768;
pub const USE_FOE: u32 = 0;
pub const USE_EOE: u32 = 0;
pub const MBXSIZE: u32 = 512;
pub const MBXSIZEBOOT: u32 = 512;
pub const MBXBUFFERS: u32 = 3;
pub const MBX0_sma: u32 = 4096;
pub const MBX0_sml: u32 = 512;
pub const MBX0_sme: u32 = 4607;
pub const MBX0_smc: u32 = 38;
pub const MBX1_sma: u32 = 4608;
pub const MBX1_sml: u32 = 512;
pub const MBX1_sme: u32 = 5119;
pub const MBX1_smc: u32 = 34;
pub const MBX0_sma_b: u32 = 4096;
pub const MBX0_sml_b: u32 = 512;
pub const MBX0_sme_b: u32 = 4607;
pub const MBX0_smc_b: u32 = 38;
pub const MBX1_sma_b: u32 = 4608;
pub const MBX1_sml_b: u32 = 512;
pub const MBX1_sme_b: u32 = 5119;
pub const MBX1_smc_b: u32 = 34;
pub const SM2_sma: u32 = 5632;
pub const SM2_smc: u32 = 36;
pub const SM2_act: u32 = 1;
pub const SM3_sma: u32 = 6656;
pub const SM3_smc: u32 = 32;
pub const SM3_act: u32 = 1;
pub const MAX_MAPPINGS_SM2: u32 = 2;
pub const MAX_MAPPINGS_SM3: u32 = 5;
pub const MAX_RXPDO_SIZE: u32 = 512;
pub const MAX_TXPDO_SIZE: u32 = 512;
pub const ESCREG_ADDRESS: u32 = 16;
pub const ESCREG_DLSTATUS: u32 = 272;
pub const ESCREG_ALCONTROL: u32 = 288;
pub const ESCREG_ALSTATUS: u32 = 304;
pub const ESCREG_ALERROR: u32 = 308;
pub const ESCREG_ALEVENTMASK: u32 = 516;
pub const ESCREG_ALEVENT: u32 = 544;
pub const ESCREG_ALEVENT_SM_MASK: u32 = 784;
pub const ESCREG_ALEVENT_SMCHANGE: u32 = 16;
pub const ESCREG_ALEVENT_CONTROL: u32 = 1;
pub const ESCREG_ALEVENT_DC_LATCH: u32 = 2;
pub const ESCREG_ALEVENT_DC_SYNC0: u32 = 4;
pub const ESCREG_ALEVENT_DC_SYNC1: u32 = 8;
pub const ESCREG_ALEVENT_EEP: u32 = 32;
pub const ESCREG_ALEVENT_WD: u32 = 64;
pub const ESCREG_ALEVENT_SM0: u32 = 256;
pub const ESCREG_ALEVENT_SM1: u32 = 512;
pub const ESCREG_ALEVENT_SM2: u32 = 1024;
pub const ESCREG_ALEVENT_SM3: u32 = 2048;
pub const ESCREG_WDSTATUS: u32 = 1088;
pub const ESCREG_EECONTSTAT: u32 = 1282;
pub const ESCREG_EEDATA: u32 = 1288;
pub const ESCREG_SM0: u32 = 2048;
pub const ESCREG_SM0STATUS: u32 = 2053;
pub const ESCREG_SM0ACTIVATE: u32 = 2054;
pub const ESCREG_SM0PDI: u32 = 2055;
pub const ESCREG_SM1: u32 = 2056;
pub const ESCREG_SM2: u32 = 2064;
pub const ESCREG_SM3: u32 = 2072;
pub const ESCREG_LOCALTIME: u32 = 2320;
pub const ESCREG_LOCALTIME_OFFSET: u32 = 2336;
pub const ESCREG_SYNC_ACT: u32 = 2433;
pub const ESCREG_SYNC_ACT_ACTIVATED: u32 = 1;
pub const ESCREG_SYNC_SYNC0_EN: u32 = 2;
pub const ESCREG_SYNC_SYNC1_EN: u32 = 4;
pub const ESCREG_SYNC_AUTO_ACTIVATED: u32 = 8;
pub const ESCREG_SYNC0_CYCLE_TIME: u32 = 2464;
pub const ESCREG_SYNC1_CYCLE_TIME: u32 = 2468;
pub const ESCREG_SMENABLE_BIT: u32 = 1;
pub const ESCREG_AL_STATEMASK: u32 = 31;
pub const ESCREG_AL_ALLBUTINITMASK: u32 = 14;
pub const ESCREG_AL_ERRACKMASK: u32 = 15;
pub const SYNCTYPE_SUPPORT_FREERUN: u32 = 1;
pub const SYNCTYPE_SUPPORT_SYNCHRON: u32 = 2;
pub const SYNCTYPE_SUPPORT_DCSYNC0: u32 = 4;
pub const SYNCTYPE_SUPPORT_DCSYNC1: u32 = 8;
pub const SYNCTYPE_SUPPORT_SUBCYCLE: u32 = 16;
pub const ESCinit: u32 = 1;
pub const ESCpreop: u32 = 2;
pub const ESCboot: u32 = 3;
pub const ESCsafeop: u32 = 4;
pub const ESCop: u32 = 8;
pub const ESCerror: u32 = 16;
pub const INIT_TO_INIT: u32 = 17;
pub const INIT_TO_PREOP: u32 = 33;
pub const INIT_TO_BOOT: u32 = 49;
pub const INIT_TO_SAFEOP: u32 = 65;
pub const INIT_TO_OP: u32 = 129;
pub const PREOP_TO_INIT: u32 = 18;
pub const PREOP_TO_PREOP: u32 = 34;
pub const PREOP_TO_BOOT: u32 = 50;
pub const PREOP_TO_SAFEOP: u32 = 66;
pub const PREOP_TO_OP: u32 = 130;
pub const BOOT_TO_INIT: u32 = 19;
pub const BOOT_TO_PREOP: u32 = 35;
pub const BOOT_TO_BOOT: u32 = 51;
pub const BOOT_TO_SAFEOP: u32 = 67;
pub const BOOT_TO_OP: u32 = 131;
pub const SAFEOP_TO_INIT: u32 = 20;
pub const SAFEOP_TO_PREOP: u32 = 36;
pub const SAFEOP_TO_BOOT: u32 = 52;
pub const SAFEOP_TO_SAFEOP: u32 = 68;
pub const SAFEOP_TO_OP: u32 = 132;
pub const OP_TO_INIT: u32 = 24;
pub const OP_TO_PREOP: u32 = 40;
pub const OP_TO_BOOT: u32 = 56;
pub const OP_TO_SAFEOP: u32 = 72;
pub const OP_TO_OP: u32 = 136;
pub const ALERR_NONE: u32 = 0;
pub const ALERR_UNSPECIFIEDERROR: u32 = 1;
pub const ALERR_NOMEMORY: u32 = 2;
pub const ALERR_INVALIDSTATECHANGE: u32 = 17;
pub const ALERR_UNKNOWNSTATE: u32 = 18;
pub const ALERR_BOOTNOTSUPPORTED: u32 = 19;
pub const ALERR_NOVALIDFIRMWARE: u32 = 20;
pub const ALERR_INVALIDBOOTMBXCONFIG: u32 = 21;
pub const ALERR_INVALIDMBXCONFIG: u32 = 22;
pub const ALERR_INVALIDSMCONFIG: u32 = 23;
pub const ALERR_NOVALIDINPUTS: u32 = 24;
pub const ALERR_NOVALIDOUTPUTS: u32 = 25;
pub const ALERR_SYNCERROR: u32 = 26;
pub const ALERR_WATCHDOG: u32 = 27;
pub const ALERR_INVALIDSYNCMANAGERTYP: u32 = 28;
pub const ALERR_INVALIDOUTPUTSM: u32 = 29;
pub const ALERR_INVALIDINPUTSM: u32 = 30;
pub const ALERR_INVALIDWDTCFG: u32 = 31;
pub const ALERR_SLAVENEEDSCOLDSTART: u32 = 32;
pub const ALERR_SLAVENEEDSINIT: u32 = 33;
pub const ALERR_SLAVENEEDSPREOP: u32 = 34;
pub const ALERR_SLAVENEEDSSAFEOP: u32 = 35;
pub const ALERR_INVALIDINPUTMAPPING: u32 = 36;
pub const ALERR_INVALIDOUTPUTMAPPING: u32 = 37;
pub const ALERR_INCONSISTENTSETTINGS: u32 = 38;
pub const ALERR_FREERUNNOTSUPPORTED: u32 = 39;
pub const ALERR_SYNCNOTSUPPORTED: u32 = 40;
pub const ALERR_FREERUNNEEDS3BUFFMODE: u32 = 41;
pub const ALERR_BACKGROUNDWATCHDOG: u32 = 42;
pub const ALERR_NOVALIDINPUTSOUTPUTS: u32 = 43;
pub const ALERR_FATALSYNCERROR: u32 = 44;
pub const ALERR_NOSYNCERROR: u32 = 45;
pub const ALERR_INVALIDINPUTFMMUCFG: u32 = 46;
pub const ALERR_DCINVALIDSYNCCFG: u32 = 48;
pub const ALERR_INVALIDDCLATCHCFG: u32 = 49;
pub const ALERR_PLLERROR: u32 = 50;
pub const ALERR_DCSYNCIOERROR: u32 = 51;
pub const ALERR_DCSYNCTIMEOUT: u32 = 52;
pub const ALERR_DCSYNCCYCLETIME: u32 = 53;
pub const ALERR_DCSYNC0CYCLETIME: u32 = 54;
pub const ALERR_DCSYNC1CYCLETIME: u32 = 55;
pub const ALERR_MBXAOE: u32 = 65;
pub const ALERR_MBXEOE: u32 = 66;
pub const ALERR_MBXCOE: u32 = 67;
pub const ALERR_MBXFOE: u32 = 68;
pub const ALERR_MBXSOE: u32 = 69;
pub const ALERR_MBXVOE: u32 = 79;
pub const ALERR_EEPROMNOACCESS: u32 = 80;
pub const ALERR_EEPROMERROR: u32 = 81;
pub const ALERR_SLAVERESTARTEDLOCALLY: u32 = 96;
pub const ALERR_DEVICEIDVALUEUPDATED: u32 = 97;
pub const ALERR_APPLCTRLAVAILABLE: u32 = 240;
pub const ALERR_UNKNOWN: u32 = 65535;
pub const MBXERR_SYNTAX: u32 = 1;
pub const MBXERR_UNSUPPORTEDPROTOCOL: u32 = 2;
pub const MBXERR_INVALIDCHANNEL: u32 = 3;
pub const MBXERR_SERVICENOTSUPPORTED: u32 = 4;
pub const MBXERR_INVALIDHEADER: u32 = 5;
pub const MBXERR_SIZETOOSHORT: u32 = 6;
pub const MBXERR_NOMOREMEMORY: u32 = 7;
pub const MBXERR_INVALIDSIZE: u32 = 8;
pub const ABORT_NOTOGGLE: u32 = 84082688;
pub const ABORT_TRANSFER_TIMEOUT: u32 = 84148224;
pub const ABORT_UNKNOWN: u32 = 84148225;
pub const ABORT_INVALID_BLOCK_SIZE: u32 = 84148226;
pub const ABORT_INVALID_SEQUENCE_NUMBER: u32 = 84148227;
pub const ABORT_BLOCK_CRC_ERROR: u32 = 84148228;
pub const ABORT_OUT_OF_MEMORY: u32 = 84148229;
pub const ABORT_UNSUPPORTED: u32 = 100728832;
pub const ABORT_WRITEONLY: u32 = 100728833;
pub const ABORT_READONLY: u32 = 100728834;
pub const ABORT_SUBINDEX0_NOT_ZERO: u32 = 100728835;
pub const ABORT_CA_NOT_SUPPORTED: u32 = 100728836;
pub const ABORT_EXCEEDS_MBOX_SIZE: u32 = 100728837;
pub const ABORT_SDO_DOWNLOAD_BLOCKED: u32 = 100728838;
pub const ABORT_NOOBJECT: u32 = 100794368;
pub const ABORT_MAPPING_OBJECT_ERROR: u32 = 100925505;
pub const ABORT_MAPPING_LENGTH_ERROR: u32 = 100925506;
pub const ABORT_GENERAL_PARAMETER_ERROR: u32 = 100925507;
pub const ABORT_GENERAL_DEVICE_ERROR: u32 = 100925511;
pub const ABORT_HARDWARE_ERROR: u32 = 101056512;
pub const ABORT_TYPEMISMATCH: u32 = 101122064;
pub const ABORT_DATATYPE_TOO_HIGH: u32 = 101122066;
pub const ABORT_DATATYPE_TOO_LOW: u32 = 101122067;
pub const ABORT_NOSUBINDEX: u32 = 101253137;
pub const ABORT_VALUE_EXCEEDED: u32 = 101253168;
pub const ABORT_VALUE_TOO_HIGH: u32 = 101253169;
pub const ABORT_VALUE_TOO_LOW: u32 = 101253170;
pub const ABORT_MODULE_LIST_MISMATCH: u32 = 101253171;
pub const ABORT_MAX_VAL_LESS_THAN_MIN_VAL: u32 = 101253174;
pub const ABORT_RESOURCE_NOT_AVAILABLE: u32 = 101318691;
pub const ABORT_GENERALERROR: u32 = 134217728;
pub const ABORT_DATA_STORE_ERROR: u32 = 134217760;
pub const ABORT_DATA_STORE_LOCAL_ERROR: u32 = 134217761;
pub const ABORT_NOTINTHISSTATE: u32 = 134217762;
pub const ABORT_OBJECT_DICTIONARY_ERROR: u32 = 134217763;
pub const ABORT_NO_DATA_AVAILABLE: u32 = 134217764;
pub const MBXstate_idle: u32 = 0;
pub const MBXstate_inclaim: u32 = 1;
pub const MBXstate_outclaim: u32 = 2;
pub const MBXstate_outreq: u32 = 3;
pub const MBXstate_outpost: u32 = 4;
pub const MBXstate_backup: u32 = 5;
pub const MBXstate_again: u32 = 6;
pub const COE_DEFAULTLENGTH: u32 = 10;
pub const COE_HEADERSIZE: u32 = 10;
pub const COE_SEGMENTHEADERSIZE: u32 = 3;
pub const COE_SDOREQUEST: u32 = 2;
pub const COE_SDORESPONSE: u32 = 3;
pub const COE_SDOINFORMATION: u32 = 8;
pub const COE_COMMAND_SDOABORT: u32 = 128;
pub const COE_COMMAND_UPLOADREQUEST: u32 = 64;
pub const COE_COMMAND_UPLOADRESPONSE: u32 = 64;
pub const COE_COMMAND_UPLOADSEGMENT: u32 = 0;
pub const COE_COMMAND_UPLOADSEGREQ: u32 = 96;
pub const COE_COMMAND_DOWNLOADREQUEST: u32 = 32;
pub const COE_COMMAND_DOWNLOADRESPONSE: u32 = 96;
pub const COE_COMMAND_DOWNLOADSEGREQ: u32 = 0;
pub const COE_COMMAND_DOWNLOADSEGRESP: u32 = 32;
pub const COE_COMMAND_LASTSEGMENTBIT: u32 = 1;
pub const COE_SIZE_INDICATOR: u32 = 1;
pub const COE_EXPEDITED_INDICATOR: u32 = 2;
pub const COE_COMPLETEACCESS: u32 = 16;
pub const COE_TOGGLEBIT: u32 = 16;
pub const COE_INFOERROR: u32 = 7;
pub const COE_GETODLISTRESPONSE: u32 = 2;
pub const COE_GETODRESPONSE: u32 = 4;
pub const COE_ENTRYDESCRIPTIONRESPONSE: u32 = 6;
pub const COE_VALUEINFO_ACCESS: u32 = 1;
pub const COE_VALUEINFO_OBJECT: u32 = 2;
pub const COE_VALUEINFO_MAPPABLE: u32 = 4;
pub const COE_VALUEINFO_TYPE: u32 = 8;
pub const COE_VALUEINFO_DEFAULT: u32 = 16;
pub const COE_VALUEINFO_MINIMUM: u32 = 32;
pub const COE_VALUEINFO_MAXIMUM: u32 = 64;
pub const COE_MINIMUM_LENGTH: u32 = 8;
pub const MBXERR: u32 = 0;
pub const MBXAOE: u32 = 1;
pub const MBXEOE: u32 = 2;
pub const MBXCOE: u32 = 3;
pub const MBXFOE: u32 = 4;
pub const MBXODL: u32 = 16;
pub const MBXOD: u32 = 32;
pub const MBXED: u32 = 48;
pub const MBXSEU: u32 = 64;
pub const MBXSED: u32 = 80;
pub const SMRESULT_ERRSM0: u32 = 1;
pub const SMRESULT_ERRSM1: u32 = 2;
pub const SMRESULT_ERRSM2: u32 = 4;
pub const SMRESULT_ERRSM3: u32 = 8;
pub const FOE_ERR_NOTDEFINED: u32 = 32768;
pub const FOE_ERR_NOTFOUND: u32 = 32769;
pub const FOE_ERR_ACCESS: u32 = 32770;
pub const FOE_ERR_DISKFULL: u32 = 32771;
pub const FOE_ERR_ILLEGAL: u32 = 32772;
pub const FOE_ERR_PACKETNO: u32 = 32773;
pub const FOE_ERR_EXISTS: u32 = 32774;
pub const FOE_ERR_NOUSER: u32 = 32775;
pub const FOE_ERR_BOOTSTRAPONLY: u32 = 32776;
pub const FOE_ERR_NOTINBOOTSTRAP: u32 = 32777;
pub const FOE_ERR_NORIGHTS: u32 = 32778;
pub const FOE_ERR_PROGERROR: u32 = 32779;
pub const FOE_ERR_CHECKSUM: u32 = 32780;
pub const FOE_OP_RRQ: u32 = 1;
pub const FOE_OP_WRQ: u32 = 2;
pub const FOE_OP_DATA: u32 = 3;
pub const FOE_OP_ACK: u32 = 4;
pub const FOE_OP_ERR: u32 = 5;
pub const FOE_OP_BUSY: u32 = 6;
pub const FOE_READY: u32 = 0;
pub const FOE_WAIT_FOR_ACK: u32 = 1;
pub const FOE_WAIT_FOR_FINAL_ACK: u32 = 2;
pub const FOE_WAIT_FOR_DATA: u32 = 3;
pub const EOE_RESULT_SUCCESS: u32 = 0;
pub const EOE_RESULT_UNSPECIFIED_ERROR: u32 = 1;
pub const EOE_RESULT_UNSUPPORTED_FRAME_TYPE: u32 = 2;
pub const EOE_RESULT_NO_IP_SUPPORT: u32 = 513;
pub const EOE_RESULT_NO_DHCP_SUPPORT: u32 = 514;
pub const EOE_RESULT_NO_FILTER_SUPPORT: u32 = 1025;
pub const APPSTATE_IDLE: u32 = 0;
pub const APPSTATE_INPUT: u32 = 1;
pub const APPSTATE_OUTPUT: u32 = 2;
pub const PREALLOC_FACTOR: u32 = 3;
pub const PREALLOC_BUFFER_SIZE: u32 = 1536;
pub const ESC_MBXBUFFERS: u32 = 3;
pub const ESC_SM2_sma: u32 = 5632;
pub const ESC_SM2_smc: u32 = 36;
pub const ESC_SM2_act: u32 = 1;
pub const ESC_SM3_sma: u32 = 6656;
pub const ESC_SM3_smc: u32 = 32;
pub const ESC_SM3_act: u32 = 1;
pub type __int8_t = cty::c_schar;
pub type __uint8_t = cty::c_uchar;
pub type __int16_t = cty::c_short;
pub type __uint16_t = cty::c_ushort;
pub type __int32_t = cty::c_int;
pub type __uint32_t = cty::c_uint;
pub type __int64_t = cty::c_longlong;
pub type __uint64_t = cty::c_ulonglong;
pub type __int_least8_t = cty::c_schar;
pub type __uint_least8_t = cty::c_uchar;
pub type __int_least16_t = cty::c_short;
pub type __uint_least16_t = cty::c_ushort;
pub type __int_least32_t = cty::c_int;
pub type __uint_least32_t = cty::c_uint;
pub type __int_least64_t = cty::c_longlong;
pub type __uint_least64_t = cty::c_ulonglong;
pub type __intmax_t = cty::c_longlong;
pub type __uintmax_t = cty::c_ulonglong;
pub type __intptr_t = cty::c_int;
pub type __uintptr_t = cty::c_uint;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = cty::c_schar;
pub type uint_fast8_t = cty::c_uchar;
pub type int_fast16_t = cty::c_short;
pub type uint_fast16_t = cty::c_ushort;
pub type int_fast32_t = cty::c_int;
pub type uint_fast32_t = cty::c_uint;
pub type int_fast64_t = cty::c_longlong;
pub type uint_fast64_t = cty::c_ulonglong;
pub type wchar_t = cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __max_align_ll: cty::c_longlong,
    pub __max_align_ld: f64,
}
pub type __gnuc_va_list = u32;
pub type va_list = __gnuc_va_list;
pub type wint_t = cty::c_int;
pub type __blkcnt_t = cty::c_long;
pub type __blksize_t = cty::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type _off_t = cty::c_long;
pub type __pid_t = cty::c_int;
pub type __dev_t = cty::c_short;
pub type __uid_t = cty::c_ushort;
pub type __gid_t = cty::c_ushort;
pub type __id_t = __uint32_t;
pub type __ino_t = cty::c_ushort;
pub type __mode_t = __uint32_t;
pub type _off64_t = cty::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = cty::c_long;
pub type _fpos_t = cty::c_long;
pub type __size_t = cty::c_uint;
pub type _ssize_t = cty::c_int;
pub type __ssize_t = _ssize_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: cty::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [cty::c_uchar; 4usize],
}
pub type _iconv_t = *mut cty::c_void;
pub type __clock_t = cty::c_ulong;
pub type __time_t = __int_least64_t;
pub type __clockid_t = cty::c_ulong;
pub type __daddr_t = cty::c_long;
pub type __timer_t = cty::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nl_item = cty::c_int;
pub type __nlink_t = cty::c_ushort;
pub type __suseconds_t = cty::c_long;
pub type __useconds_t = cty::c_ulong;
pub type __va_list = u32;
pub type __ULong = cty::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lock {
    _unused: [u8; 0],
}
pub type _LOCK_T = *mut __lock;
unsafe extern "C" {
    pub fn __retarget_lock_init(lock: *mut _LOCK_T);
}
unsafe extern "C" {
    pub fn __retarget_lock_init_recursive(lock: *mut _LOCK_T);
}
unsafe extern "C" {
    pub fn __retarget_lock_close(lock: _LOCK_T);
}
unsafe extern "C" {
    pub fn __retarget_lock_close_recursive(lock: _LOCK_T);
}
unsafe extern "C" {
    pub fn __retarget_lock_acquire(lock: _LOCK_T);
}
unsafe extern "C" {
    pub fn __retarget_lock_acquire_recursive(lock: _LOCK_T);
}
unsafe extern "C" {
    pub fn __retarget_lock_try_acquire(lock: _LOCK_T) -> cty::c_int;
}
unsafe extern "C" {
    pub fn __retarget_lock_try_acquire_recursive(lock: _LOCK_T) -> cty::c_int;
}
unsafe extern "C" {
    pub fn __retarget_lock_release(lock: _LOCK_T);
}
unsafe extern "C" {
    pub fn __retarget_lock_release_recursive(lock: _LOCK_T);
}
pub type _flock_t = _LOCK_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: cty::c_int,
    pub _maxwds: cty::c_int,
    pub _sign: cty::c_int,
    pub _wds: cty::c_int,
    pub _x: [__ULong; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: cty::c_int,
    pub __tm_min: cty::c_int,
    pub __tm_hour: cty::c_int,
    pub __tm_mday: cty::c_int,
    pub __tm_mon: cty::c_int,
    pub __tm_year: cty::c_int,
    pub __tm_wday: cty::c_int,
    pub __tm_yday: cty::c_int,
    pub __tm_isdst: cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut cty::c_void; 32usize],
    pub _dso_handle: [*mut cty::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: cty::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args: _on_exit_args,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut cty::c_uchar,
    pub _size: cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut cty::c_uchar,
    pub _r: cty::c_int,
    pub _w: cty::c_int,
    pub _flags: cty::c_short,
    pub _file: cty::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: cty::c_int,
    pub _cookie: *mut cty::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut cty::c_void,
            arg3: *mut cty::c_char,
            arg4: cty::c_int,
        ) -> cty::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut cty::c_void,
            arg3: *const cty::c_char,
            arg4: cty::c_int,
        ) -> cty::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut cty::c_void,
            arg3: _fpos_t,
            arg4: cty::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut cty::c_void) -> cty::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut cty::c_uchar,
    pub _ur: cty::c_int,
    pub _ubuf: [cty::c_uchar; 3usize],
    pub _nbuf: [cty::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: cty::c_int,
    pub _offset: _off_t,
    pub _data: *mut _reent,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: cty::c_int,
}
pub type __FILE = __sFILE;
unsafe extern "C" {
    pub static mut __sf: [__FILE; 3usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: cty::c_int,
    pub _iobs: *mut __FILE,
}
unsafe extern "C" {
    pub static mut __sglue: _glue;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [cty::c_ushort; 3usize],
    pub _mult: [cty::c_ushort; 3usize],
    pub _add: cty::c_ushort,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent {
    pub _errno: cty::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: cty::c_int,
    pub _emergency: [cty::c_char; 25usize],
    pub _locale: *mut __locale_t,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _result: *mut _Bigint,
    pub _result_k: cty::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
    pub _cvtlen: cty::c_int,
    pub _cvtbuf: *mut cty::c_char,
    pub _new: _reent__bindgen_ty_1,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: cty::c_int)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _reent__bindgen_ty_1 {
    pub _reent: _reent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_1 {
    pub _strtok_last: *mut cty::c_char,
    pub _asctime_buf: [cty::c_char; 26usize],
    pub _localtime_buf: __tm,
    pub _gamma_signgam: cty::c_int,
    pub _rand_next: cty::c_ulonglong,
    pub _r48: _rand48,
    pub _mblen_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _l64a_buf: [cty::c_char; 8usize],
    pub _signal_buf: [cty::c_char; 24usize],
    pub _getdate_err: cty::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
    pub _h_errno: cty::c_int,
    pub _getlocalename_l_buf: [cty::c_char; 32usize],
}
unsafe extern "C" {
    pub static mut _impure_ptr: *mut _reent;
}
unsafe extern "C" {
    pub static mut _impure_data: _reent;
}
unsafe extern "C" {
    pub static mut __atexit: *mut _atexit;
}
unsafe extern "C" {
    pub static mut __atexit0: _atexit;
}
unsafe extern "C" {
    pub static mut __stdio_exit_handler: ::core::option::Option<unsafe extern "C" fn()>;
}
unsafe extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
unsafe extern "C" {
    pub fn _fwalk_sglue(
        arg1: *mut _reent,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut __FILE) -> cty::c_int,
        >,
        arg3: *mut _glue,
    ) -> cty::c_int;
}
pub type FILE = __FILE;
pub type fpos_t = _fpos_t;
pub type off_t = __off_t;
unsafe extern "C" {
    pub fn ctermid(arg1: *mut cty::c_char) -> *mut cty::c_char;
}
unsafe extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
unsafe extern "C" {
    pub fn tmpnam(arg1: *mut cty::c_char) -> *mut cty::c_char;
}
unsafe extern "C" {
    pub fn tempnam(arg1: *const cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
unsafe extern "C" {
    pub fn fclose(arg1: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn fflush(arg1: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn freopen(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut cty::c_char);
}
unsafe extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut cty::c_char,
        arg3: cty::c_int,
        arg4: usize,
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn fprintf(arg1: *mut FILE, arg2: *const cty::c_char, ...) -> cty::c_int;
}
unsafe extern "C" {
    pub fn fscanf(arg1: *mut FILE, arg2: *const cty::c_char, ...) -> cty::c_int;
}
unsafe extern "C" {
    pub fn printf(arg1: *const cty::c_char, ...) -> cty::c_int;
}
unsafe extern "C" {
    pub fn scanf(arg1: *const cty::c_char, ...) -> cty::c_int;
}
unsafe extern "C" {
    pub fn sscanf(arg1: *const cty::c_char, arg2: *const cty::c_char, ...) -> cty::c_int;
}
unsafe extern "C" {
    pub fn vfprintf(arg1: *mut FILE, arg2: *const cty::c_char, arg3: u32) -> cty::c_int;
}
unsafe extern "C" {
    pub fn vprintf(arg1: *const cty::c_char, arg2: u32) -> cty::c_int;
}
unsafe extern "C" {
    pub fn vsprintf(arg1: *mut cty::c_char, arg2: *const cty::c_char, arg3: u32) -> cty::c_int;
}
unsafe extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn fgets(arg1: *mut cty::c_char, arg2: cty::c_int, arg3: *mut FILE) -> *mut cty::c_char;
}
unsafe extern "C" {
    pub fn fputc(arg1: cty::c_int, arg2: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn fputs(arg1: *const cty::c_char, arg2: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn getc(arg1: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn getchar() -> cty::c_int;
}
unsafe extern "C" {
    pub fn gets(arg1: *mut cty::c_char) -> *mut cty::c_char;
}
unsafe extern "C" {
    pub fn putc(arg1: cty::c_int, arg2: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn putchar(arg1: cty::c_int) -> cty::c_int;
}
unsafe extern "C" {
    pub fn puts(arg1: *const cty::c_char) -> cty::c_int;
}
unsafe extern "C" {
    pub fn ungetc(arg1: cty::c_int, arg2: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn fread(
        arg1: *mut cty::c_void,
        _size: cty::c_uint,
        _n: cty::c_uint,
        arg2: *mut FILE,
    ) -> cty::c_uint;
}
unsafe extern "C" {
    pub fn fwrite(
        arg1: *const cty::c_void,
        _size: cty::c_uint,
        _n: cty::c_uint,
        arg2: *mut FILE,
    ) -> cty::c_uint;
}
unsafe extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> cty::c_int;
}
unsafe extern "C" {
    pub fn fseek(arg1: *mut FILE, arg2: cty::c_long, arg3: cty::c_int) -> cty::c_int;
}
unsafe extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> cty::c_int;
}
unsafe extern "C" {
    pub fn ftell(arg1: *mut FILE) -> cty::c_long;
}
unsafe extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
unsafe extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
unsafe extern "C" {
    pub fn feof(arg1: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn ferror(arg1: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn perror(arg1: *const cty::c_char);
}
unsafe extern "C" {
    pub fn fopen(_name: *const cty::c_char, _type: *const cty::c_char) -> *mut FILE;
}
unsafe extern "C" {
    pub fn sprintf(arg1: *mut cty::c_char, arg2: *const cty::c_char, ...) -> cty::c_int;
}
unsafe extern "C" {
    pub fn remove(arg1: *const cty::c_char) -> cty::c_int;
}
unsafe extern "C" {
    pub fn rename(arg1: *const cty::c_char, arg2: *const cty::c_char) -> cty::c_int;
}
unsafe extern "C" {
    pub fn fseeko(arg1: *mut FILE, arg2: off_t, arg3: cty::c_int) -> cty::c_int;
}
unsafe extern "C" {
    pub fn ftello(arg1: *mut FILE) -> off_t;
}
unsafe extern "C" {
    pub fn snprintf(
        arg1: *mut cty::c_char,
        arg2: cty::c_uint,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn vsnprintf(
        arg1: *mut cty::c_char,
        arg2: cty::c_uint,
        arg3: *const cty::c_char,
        arg4: u32,
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn vfscanf(arg1: *mut FILE, arg2: *const cty::c_char, arg3: u32) -> cty::c_int;
}
unsafe extern "C" {
    pub fn vscanf(arg1: *const cty::c_char, arg2: u32) -> cty::c_int;
}
unsafe extern "C" {
    pub fn vsscanf(arg1: *const cty::c_char, arg2: *const cty::c_char, arg3: u32) -> cty::c_int;
}
unsafe extern "C" {
    pub fn asiprintf(arg1: *mut *mut cty::c_char, arg2: *const cty::c_char, ...) -> cty::c_int;
}
unsafe extern "C" {
    pub fn asniprintf(
        arg1: *mut cty::c_char,
        arg2: *mut usize,
        arg3: *const cty::c_char,
        ...
    ) -> *mut cty::c_char;
}
unsafe extern "C" {
    pub fn asnprintf(
        arg1: *mut cty::c_char,
        arg2: *mut usize,
        arg3: *const cty::c_char,
        ...
    ) -> *mut cty::c_char;
}
unsafe extern "C" {
    pub fn diprintf(arg1: cty::c_int, arg2: *const cty::c_char, ...) -> cty::c_int;
}
unsafe extern "C" {
    pub fn fiprintf(arg1: *mut FILE, arg2: *const cty::c_char, ...) -> cty::c_int;
}
unsafe extern "C" {
    pub fn fiscanf(arg1: *mut FILE, arg2: *const cty::c_char, ...) -> cty::c_int;
}
unsafe extern "C" {
    pub fn iprintf(arg1: *const cty::c_char, ...) -> cty::c_int;
}
unsafe extern "C" {
    pub fn iscanf(arg1: *const cty::c_char, ...) -> cty::c_int;
}
unsafe extern "C" {
    pub fn siprintf(arg1: *mut cty::c_char, arg2: *const cty::c_char, ...) -> cty::c_int;
}
unsafe extern "C" {
    pub fn siscanf(arg1: *const cty::c_char, arg2: *const cty::c_char, ...) -> cty::c_int;
}
unsafe extern "C" {
    pub fn sniprintf(
        arg1: *mut cty::c_char,
        arg2: usize,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn vasiprintf(
        arg1: *mut *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn vasniprintf(
        arg1: *mut cty::c_char,
        arg2: *mut usize,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut cty::c_char;
}
unsafe extern "C" {
    pub fn vasnprintf(
        arg1: *mut cty::c_char,
        arg2: *mut usize,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut cty::c_char;
}
unsafe extern "C" {
    pub fn vdiprintf(
        arg1: cty::c_int,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn vfiprintf(arg1: *mut FILE, arg2: *const cty::c_char, arg3: __gnuc_va_list)
        -> cty::c_int;
}
unsafe extern "C" {
    pub fn vfiscanf(arg1: *mut FILE, arg2: *const cty::c_char, arg3: __gnuc_va_list) -> cty::c_int;
}
unsafe extern "C" {
    pub fn viprintf(arg1: *const cty::c_char, arg2: __gnuc_va_list) -> cty::c_int;
}
unsafe extern "C" {
    pub fn viscanf(arg1: *const cty::c_char, arg2: __gnuc_va_list) -> cty::c_int;
}
unsafe extern "C" {
    pub fn vsiprintf(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn vsiscanf(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn vsniprintf(
        arg1: *mut cty::c_char,
        arg2: usize,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn fdopen(arg1: cty::c_int, arg2: *const cty::c_char) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fileno(arg1: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn pclose(arg1: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn popen(arg1: *const cty::c_char, arg2: *const cty::c_char) -> *mut FILE;
}
unsafe extern "C" {
    pub fn setbuffer(arg1: *mut FILE, arg2: *mut cty::c_char, arg3: cty::c_int);
}
unsafe extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn getw(arg1: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn putw(arg1: cty::c_int, arg2: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn getchar_unlocked() -> cty::c_int;
}
unsafe extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
unsafe extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
unsafe extern "C" {
    pub fn putc_unlocked(arg1: cty::c_int, arg2: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn putchar_unlocked(arg1: cty::c_int) -> cty::c_int;
}
unsafe extern "C" {
    pub fn dprintf(arg1: cty::c_int, arg2: *const cty::c_char, ...) -> cty::c_int;
}
unsafe extern "C" {
    pub fn fmemopen(arg1: *mut cty::c_void, arg2: usize, arg3: *const cty::c_char) -> *mut FILE;
}
unsafe extern "C" {
    pub fn open_memstream(arg1: *mut *mut cty::c_char, arg2: *mut usize) -> *mut FILE;
}
unsafe extern "C" {
    pub fn vdprintf(arg1: cty::c_int, arg2: *const cty::c_char, arg3: __gnuc_va_list)
        -> cty::c_int;
}
unsafe extern "C" {
    pub fn renameat(
        arg1: cty::c_int,
        arg2: *const cty::c_char,
        arg3: cty::c_int,
        arg4: *const cty::c_char,
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _asiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut cty::c_char,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _asniprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *mut usize,
        arg4: *const cty::c_char,
        ...
    ) -> *mut cty::c_char;
}
unsafe extern "C" {
    pub fn _asnprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *mut usize,
        arg4: *const cty::c_char,
        ...
    ) -> *mut cty::c_char;
}
unsafe extern "C" {
    pub fn _asprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut cty::c_char,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _diprintf_r(
        arg1: *mut _reent,
        arg2: cty::c_int,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _dprintf_r(
        arg1: *mut _reent,
        arg2: cty::c_int,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _fclose_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _fcloseall_r(arg1: *mut _reent) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _fdopen_r(arg1: *mut _reent, arg2: cty::c_int, arg3: *const cty::c_char) -> *mut FILE;
}
unsafe extern "C" {
    pub fn _fflush_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _fgetc_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _fgetc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _fgets_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: cty::c_int,
        arg4: *mut FILE,
    ) -> *mut cty::c_char;
}
unsafe extern "C" {
    pub fn _fgets_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: cty::c_int,
        arg4: *mut FILE,
    ) -> *mut cty::c_char;
}
unsafe extern "C" {
    pub fn _fgetpos_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *mut fpos_t) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _fsetpos_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *const fpos_t) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _fiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _fiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _fmemopen_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_void,
        arg3: usize,
        arg4: *const cty::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn _fopen_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *const cty::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn _freopen_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *const cty::c_char,
        arg4: *mut FILE,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn _fprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _fpurge_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _fputc_r(arg1: *mut _reent, arg2: cty::c_int, arg3: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _fputc_unlocked_r(arg1: *mut _reent, arg2: cty::c_int, arg3: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _fputs_r(arg1: *mut _reent, arg2: *const cty::c_char, arg3: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _fputs_unlocked_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *mut FILE,
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _fread_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn _fread_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn _fscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _fseek_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: cty::c_long,
        arg4: cty::c_int,
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _fseeko_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: _off_t,
        arg4: cty::c_int,
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _ftell_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_long;
}
unsafe extern "C" {
    pub fn _ftello_r(arg1: *mut _reent, arg2: *mut FILE) -> _off_t;
}
unsafe extern "C" {
    pub fn _rewind_r(arg1: *mut _reent, arg2: *mut FILE);
}
unsafe extern "C" {
    pub fn _fwrite_r(
        arg1: *mut _reent,
        arg2: *const cty::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn _fwrite_unlocked_r(
        arg1: *mut _reent,
        arg2: *const cty::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn _getc_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _getc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _getchar_r(arg1: *mut _reent) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _getchar_unlocked_r(arg1: *mut _reent) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _gets_r(arg1: *mut _reent, arg2: *mut cty::c_char) -> *mut cty::c_char;
}
unsafe extern "C" {
    pub fn _iprintf_r(arg1: *mut _reent, arg2: *const cty::c_char, ...) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _iscanf_r(arg1: *mut _reent, arg2: *const cty::c_char, ...) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _open_memstream_r(
        arg1: *mut _reent,
        arg2: *mut *mut cty::c_char,
        arg3: *mut usize,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn _perror_r(arg1: *mut _reent, arg2: *const cty::c_char);
}
unsafe extern "C" {
    pub fn _printf_r(arg1: *mut _reent, arg2: *const cty::c_char, ...) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _putc_r(arg1: *mut _reent, arg2: cty::c_int, arg3: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _putc_unlocked_r(arg1: *mut _reent, arg2: cty::c_int, arg3: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _putchar_unlocked_r(arg1: *mut _reent, arg2: cty::c_int) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _putchar_r(arg1: *mut _reent, arg2: cty::c_int) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _puts_r(arg1: *mut _reent, arg2: *const cty::c_char) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _remove_r(arg1: *mut _reent, arg2: *const cty::c_char) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _rename_r(
        arg1: *mut _reent,
        _old: *const cty::c_char,
        _new: *const cty::c_char,
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _scanf_r(arg1: *mut _reent, arg2: *const cty::c_char, ...) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _siprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _siscanf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _sniprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: usize,
        arg4: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _snprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: usize,
        arg4: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _sprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _sscanf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _tempnam_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *const cty::c_char,
    ) -> *mut cty::c_char;
}
unsafe extern "C" {
    pub fn _tmpfile_r(arg1: *mut _reent) -> *mut FILE;
}
unsafe extern "C" {
    pub fn _tmpnam_r(arg1: *mut _reent, arg2: *mut cty::c_char) -> *mut cty::c_char;
}
unsafe extern "C" {
    pub fn _ungetc_r(arg1: *mut _reent, arg2: cty::c_int, arg3: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _vasiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut cty::c_char,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _vasniprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *mut usize,
        arg4: *const cty::c_char,
        arg5: __gnuc_va_list,
    ) -> *mut cty::c_char;
}
unsafe extern "C" {
    pub fn _vasnprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *mut usize,
        arg4: *const cty::c_char,
        arg5: __gnuc_va_list,
    ) -> *mut cty::c_char;
}
unsafe extern "C" {
    pub fn _vasprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut cty::c_char,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _vdiprintf_r(
        arg1: *mut _reent,
        arg2: cty::c_int,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _vdprintf_r(
        arg1: *mut _reent,
        arg2: cty::c_int,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _vfiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _vfiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _vfprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _vfscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _viprintf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _viscanf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _vprintf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _vscanf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _vsiprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _vsiscanf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _vsniprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: usize,
        arg4: *const cty::c_char,
        arg5: __gnuc_va_list,
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _vsnprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: usize,
        arg4: *const cty::c_char,
        arg5: __gnuc_va_list,
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _vsprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn _vsscanf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn __getdelim(
        arg1: *mut *mut cty::c_char,
        arg2: *mut usize,
        arg3: cty::c_int,
        arg4: *mut FILE,
    ) -> isize;
}
unsafe extern "C" {
    pub fn __getline(arg1: *mut *mut cty::c_char, arg2: *mut usize, arg3: *mut FILE) -> isize;
}
unsafe extern "C" {
    pub fn clearerr_unlocked(arg1: *mut FILE);
}
unsafe extern "C" {
    pub fn feof_unlocked(arg1: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn ferror_unlocked(arg1: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn fileno_unlocked(arg1: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn fflush_unlocked(arg1: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn fgetc_unlocked(arg1: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn fputc_unlocked(arg1: cty::c_int, arg2: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn fread_unlocked(
        arg1: *mut cty::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn fwrite_unlocked(
        arg1: *const cty::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn __srget_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn __swbuf_r(arg1: *mut _reent, arg2: cty::c_int, arg3: *mut FILE) -> cty::c_int;
}
unsafe extern "C" {
    pub fn funopen(
        __cookie: *const cty::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut cty::c_void,
                __buf: *mut cty::c_char,
                __n: cty::c_int,
            ) -> cty::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut cty::c_void,
                __buf: *const cty::c_char,
                __n: cty::c_int,
            ) -> cty::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut cty::c_void,
                __off: fpos_t,
                __whence: cty::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut cty::c_void) -> cty::c_int,
        >,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn _funopen_r(
        arg1: *mut _reent,
        __cookie: *const cty::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut cty::c_void,
                __buf: *mut cty::c_char,
                __n: cty::c_int,
            ) -> cty::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut cty::c_void,
                __buf: *const cty::c_char,
                __n: cty::c_int,
            ) -> cty::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut cty::c_void,
                __off: fpos_t,
                __whence: cty::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut cty::c_void) -> cty::c_int,
        >,
    ) -> *mut FILE;
}
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = __intptr_t;
pub type __sigset_t = cty::c_ulong;
pub type suseconds_t = __suseconds_t;
pub type time_t = __int_least64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: cty::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
pub type sigset_t = __sigset_t;
pub type __fd_mask = cty::c_ulong;
pub type fd_mask = __fd_mask;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 2usize],
}
unsafe extern "C" {
    pub fn select(
        __n: cty::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn pselect(
        __n: cty::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __set: *const sigset_t,
    ) -> cty::c_int;
}
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type u_register_t = __uintptr_t;
pub type u_char = cty::c_uchar;
pub type u_short = cty::c_ushort;
pub type u_int = cty::c_uint;
pub type u_long = cty::c_ulong;
pub type ushort = cty::c_ushort;
pub type uint = cty::c_uint;
pub type ulong = cty::c_ulong;
pub type blkcnt_t = __blkcnt_t;
pub type blksize_t = __blksize_t;
pub type clock_t = cty::c_ulong;
pub type daddr_t = __daddr_t;
pub type caddr_t = *mut cty::c_char;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type uid_t = __uid_t;
pub type gid_t = __gid_t;
pub type pid_t = __pid_t;
pub type key_t = __key_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type sbintime_t = __int64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: cty::c_int,
}
pub type pthread_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr_t {
    pub is_initialized: cty::c_int,
    pub stackaddr: *mut cty::c_void,
    pub stacksize: cty::c_int,
    pub contentionscope: cty::c_int,
    pub inheritsched: cty::c_int,
    pub schedpolicy: cty::c_int,
    pub schedparam: sched_param,
    pub detachstate: cty::c_int,
}
pub type pthread_mutex_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutexattr_t {
    pub is_initialized: cty::c_int,
    pub recursive: cty::c_int,
}
pub type pthread_cond_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_condattr_t {
    pub is_initialized: cty::c_int,
    pub clock: clock_t,
}
pub type pthread_key_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_once_t {
    pub is_initialized: cty::c_int,
    pub init_executed: cty::c_int,
}
pub type putcf =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void, arg2: cty::c_char)>;
unsafe extern "C" {
    pub fn tfp_format(putp: *mut cty::c_void, putf: putcf, fmt: *const cty::c_char, va: va_list);
}
unsafe extern "C" {
    pub fn tfp_vsnprintf(
        str_: *mut cty::c_char,
        size: usize,
        fmt: *const cty::c_char,
        ap: va_list,
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn tfp_snprintf(
        str_: *mut cty::c_char,
        size: usize,
        fmt: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
unsafe extern "C" {
    pub fn tfp_vsprintf(str_: *mut cty::c_char, fmt: *const cty::c_char, ap: va_list)
        -> cty::c_int;
}
unsafe extern "C" {
    pub fn tfp_sprintf(str_: *mut cty::c_char, fmt: *const cty::c_char, ...) -> cty::c_int;
}
unsafe extern "C" {
    pub fn init_printf(putp: *mut cty::c_void, putf: putcf);
}
unsafe extern "C" {
    pub fn tfp_printf(fmt: *mut cty::c_char, ...);
}
unsafe extern "C" {
    pub fn DPRINT_RUST(msg: *const cty::c_char);
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _objd {
    pub subindex: u16,
    pub datatype: u16,
    pub bitlength: u16,
    pub flags: u16,
    pub name: *const cty::c_char,
    pub value: u32,
    pub data: *mut cty::c_void,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _objectlist {
    pub index: u16,
    pub objtype: u16,
    pub maxsub: u8,
    pub pad1: u8,
    pub name: *const cty::c_char,
    pub objdesc: *const _objd,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SMmap {
    pub obj: *const _objd,
    pub offset: u16,
}
unsafe extern "C" {
    pub fn ESC_coeprocess();
}
unsafe extern "C" {
    pub fn SDO_findsubindex(nidx: i16, subindex: u8) -> i16;
}
unsafe extern "C" {
    pub fn SDO_findobject(index: u16) -> i32;
}
unsafe extern "C" {
    pub fn sizeOfPDO(
        index: u16,
        nmappings: *mut cty::c_int,
        sm: *mut _SMmap,
        max_mappings: cty::c_int,
    ) -> u16;
}
unsafe extern "C" {
    pub fn SDO_abort(index: u16, subindex: u8, abortcode: u32);
}
unsafe extern "C" {
    pub fn COE_initDefaultValues();
}
unsafe extern "C" {
    pub fn COE_pdoPack(buffer: *mut u8, nmappings: cty::c_int, sm: *mut _SMmap);
}
unsafe extern "C" {
    pub fn COE_pdoUnpack(buffer: *mut u8, nmappings: cty::c_int, sm: *mut _SMmap);
}
unsafe extern "C" {
    pub fn COE_maxSub(index: u16) -> u8;
}
unsafe extern "C" {
    pub fn ESC_download_post_objecthandler(index: u16, subindex: u8, flags: u16) -> u32;
}
unsafe extern "C" {
    pub fn ESC_download_pre_objecthandler(
        index: u16,
        subindex: u8,
        data: *mut cty::c_void,
        size: usize,
        flags: u16,
    ) -> u32;
}
unsafe extern "C" {
    pub fn ESC_upload_pre_objecthandler(
        index: u16,
        subindex: u8,
        data: *mut cty::c_void,
        size: usize,
        flags: u16,
    ) -> u32;
}
unsafe extern "C" {
    pub fn ESC_upload_post_objecthandler(index: u16, subindex: u8, flags: u16) -> u32;
}
unsafe extern "C" {
    pub static SDOobjects: [_objectlist; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sm_cfg {
    pub cfg_sma: u16,
    pub cfg_sml: u16,
    pub cfg_sme: u16,
    pub cfg_smc: u8,
    pub cfg_smact: u8,
}
pub type sm_cfg_t = sm_cfg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esc_cfg {
    pub user_arg: *mut cty::c_void,
    pub use_interrupt: cty::c_int,
    pub watchdog_cnt: cty::c_int,
    pub skip_default_initialization: bool,
    pub set_defaults_hook: ::core::option::Option<unsafe extern "C" fn()>,
    pub pre_state_change_hook:
        ::core::option::Option<unsafe extern "C" fn(as_: *mut u8, an: *mut u8)>,
    pub post_state_change_hook:
        ::core::option::Option<unsafe extern "C" fn(as_: *mut u8, an: *mut u8)>,
    pub application_hook: ::core::option::Option<unsafe extern "C" fn()>,
    pub safeoutput_override: ::core::option::Option<unsafe extern "C" fn()>,
    pub pre_object_download_hook: ::core::option::Option<
        unsafe extern "C" fn(
            index: u16,
            subindex: u8,
            data: *mut cty::c_void,
            size: usize,
            flags: u16,
        ) -> u32,
    >,
    pub post_object_download_hook:
        ::core::option::Option<unsafe extern "C" fn(index: u16, subindex: u8, flags: u16) -> u32>,
    pub pre_object_upload_hook: ::core::option::Option<
        unsafe extern "C" fn(
            index: u16,
            subindex: u8,
            data: *mut cty::c_void,
            size: usize,
            flags: u16,
        ) -> u32,
    >,
    pub post_object_upload_hook:
        ::core::option::Option<unsafe extern "C" fn(index: u16, subindex: u8, flags: u16) -> u32>,
    pub rxpdo_override: ::core::option::Option<unsafe extern "C" fn()>,
    pub txpdo_override: ::core::option::Option<unsafe extern "C" fn()>,
    pub esc_hw_interrupt_enable: ::core::option::Option<unsafe extern "C" fn(mask: u32)>,
    pub esc_hw_interrupt_disable: ::core::option::Option<unsafe extern "C" fn(mask: u32)>,
    pub esc_hw_eep_handler: ::core::option::Option<unsafe extern "C" fn()>,
    pub esc_check_dc_handler: ::core::option::Option<unsafe extern "C" fn() -> u16>,
}
pub type esc_cfg_t = esc_cfg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _App {
    pub state: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _ESCsm {
    pub PSA: u16,
    pub Length: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _ESCsm {
    #[inline]
    pub fn Mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Mode_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Mode_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Direction(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Direction(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Direction_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Direction_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IntECAT(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IntECAT(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IntECAT_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_IntECAT_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IntPDI(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IntPDI(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IntPDI_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_IntPDI_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn WTE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WTE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn WTE_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_WTE_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn R1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_R1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn R1_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_R1_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IntW(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IntW(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IntW_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_IntW_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IntR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IntR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IntR_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_IntR_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn R2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_R2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn R2_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_R2_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MBXstat(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MBXstat(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MBXstat_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_MBXstat_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn BUFstat(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_BUFstat(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn BUFstat_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_BUFstat_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn R3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_R3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn R3_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_R3_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ECsm(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ECsm(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ECsm_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ECsm_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ECrep(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ECrep(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ECrep_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ECrep_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ECr4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_ECr4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ECr4_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ECr4_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EClatchEC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_EClatchEC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EClatchEC_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_EClatchEC_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EClatchPDI(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_EClatchPDI(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EClatchPDI_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_EClatchPDI_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PDIsm(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PDIsm(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PDIsm_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_PDIsm_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PDIrep(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PDIrep(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PDIrep_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                25usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_PDIrep_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                25usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PDIr5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_PDIr5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PDIr5_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                26usize,
                6u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_PDIr5_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                26usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Mode: u8,
        Direction: u8,
        IntECAT: u8,
        IntPDI: u8,
        WTE: u8,
        R1: u8,
        IntW: u8,
        IntR: u8,
        R2: u8,
        MBXstat: u8,
        BUFstat: u8,
        R3: u8,
        ECsm: u8,
        ECrep: u8,
        ECr4: u8,
        EClatchEC: u8,
        EClatchPDI: u8,
        PDIsm: u8,
        PDIrep: u8,
        PDIr5: u8,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let Mode: u8 = unsafe { ::core::mem::transmute(Mode) };
            Mode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let Direction: u8 = unsafe { ::core::mem::transmute(Direction) };
            Direction as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let IntECAT: u8 = unsafe { ::core::mem::transmute(IntECAT) };
            IntECAT as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let IntPDI: u8 = unsafe { ::core::mem::transmute(IntPDI) };
            IntPDI as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let WTE: u8 = unsafe { ::core::mem::transmute(WTE) };
            WTE as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let R1: u8 = unsafe { ::core::mem::transmute(R1) };
            R1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let IntW: u8 = unsafe { ::core::mem::transmute(IntW) };
            IntW as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let IntR: u8 = unsafe { ::core::mem::transmute(IntR) };
            IntR as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let R2: u8 = unsafe { ::core::mem::transmute(R2) };
            R2 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let MBXstat: u8 = unsafe { ::core::mem::transmute(MBXstat) };
            MBXstat as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let BUFstat: u8 = unsafe { ::core::mem::transmute(BUFstat) };
            BUFstat as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let R3: u8 = unsafe { ::core::mem::transmute(R3) };
            R3 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let ECsm: u8 = unsafe { ::core::mem::transmute(ECsm) };
            ECsm as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let ECrep: u8 = unsafe { ::core::mem::transmute(ECrep) };
            ECrep as u64
        });
        __bindgen_bitfield_unit.set(18usize, 4u8, {
            let ECr4: u8 = unsafe { ::core::mem::transmute(ECr4) };
            ECr4 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let EClatchEC: u8 = unsafe { ::core::mem::transmute(EClatchEC) };
            EClatchEC as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let EClatchPDI: u8 = unsafe { ::core::mem::transmute(EClatchPDI) };
            EClatchPDI as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let PDIsm: u8 = unsafe { ::core::mem::transmute(PDIsm) };
            PDIsm as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let PDIrep: u8 = unsafe { ::core::mem::transmute(PDIrep) };
            PDIrep as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let PDIr5: u8 = unsafe { ::core::mem::transmute(PDIr5) };
            PDIr5 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _ESCsm2 {
    pub PSA: u16,
    pub Length: u16,
    pub Command: u8,
    pub Status: u8,
    pub ActESC: u8,
    pub ActPDI: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _ESCsmCompact {
    pub PSA: u16,
    pub Length: u16,
    pub Command: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ESCvar {
    pub use_interrupt: cty::c_int,
    pub mb: [sm_cfg_t; 2usize],
    pub mbboot: [sm_cfg_t; 2usize],
    pub skip_default_initialization: bool,
    pub set_defaults_hook: ::core::option::Option<unsafe extern "C" fn()>,
    pub pre_state_change_hook:
        ::core::option::Option<unsafe extern "C" fn(as_: *mut u8, an: *mut u8)>,
    pub post_state_change_hook:
        ::core::option::Option<unsafe extern "C" fn(as_: *mut u8, an: *mut u8)>,
    pub application_hook: ::core::option::Option<unsafe extern "C" fn()>,
    pub safeoutput_override: ::core::option::Option<unsafe extern "C" fn()>,
    pub pre_object_download_hook: ::core::option::Option<
        unsafe extern "C" fn(
            index: u16,
            subindex: u8,
            data: *mut cty::c_void,
            size: usize,
            flags: u16,
        ) -> u32,
    >,
    pub post_object_download_hook:
        ::core::option::Option<unsafe extern "C" fn(index: u16, subindex: u8, flags: u16) -> u32>,
    pub pre_object_upload_hook: ::core::option::Option<
        unsafe extern "C" fn(
            index: u16,
            subindex: u8,
            data: *mut cty::c_void,
            size: usize,
            flags: u16,
        ) -> u32,
    >,
    pub post_object_upload_hook:
        ::core::option::Option<unsafe extern "C" fn(index: u16, subindex: u8, flags: u16) -> u32>,
    pub rxpdo_override: ::core::option::Option<unsafe extern "C" fn()>,
    pub txpdo_override: ::core::option::Option<unsafe extern "C" fn()>,
    pub esc_hw_interrupt_enable: ::core::option::Option<unsafe extern "C" fn(mask: u32)>,
    pub esc_hw_interrupt_disable: ::core::option::Option<unsafe extern "C" fn(mask: u32)>,
    pub esc_hw_eep_handler: ::core::option::Option<unsafe extern "C" fn()>,
    pub esc_check_dc_handler: ::core::option::Option<unsafe extern "C" fn() -> u16>,
    pub MBXrun: u8,
    pub activembxsize: usize,
    pub activemb0: *mut sm_cfg_t,
    pub activemb1: *mut sm_cfg_t,
    pub ESC_SM2_sml: u16,
    pub ESC_SM3_sml: u16,
    pub dcsync: u8,
    pub synccounterlimit: u16,
    pub ALstatus: u16,
    pub ALcontrol: u16,
    pub ALerror: u16,
    pub DLstatus: u16,
    pub address: u16,
    pub mbxcnt: u8,
    pub mbxincnt: u8,
    pub mbxoutpost: u8,
    pub mbxbackup: u8,
    pub xoe: u8,
    pub txcue: u8,
    pub mbxfree: u8,
    pub segmented: u8,
    pub data: *mut cty::c_void,
    pub entries: u16,
    pub frags: u16,
    pub fragsleft: u16,
    pub index: u16,
    pub subindex: u8,
    pub flags: u16,
    pub toggle: u8,
    pub sm2mappings: cty::c_int,
    pub sm3mappings: cty::c_int,
    pub SMtestresult: u8,
    pub PrevTime: u32,
    pub SM: [_ESCsm; 4usize],
    pub watchdogcnt: cty::c_int,
    pub Time: u32,
    pub ALevent: u16,
    pub synccounter: i8,
    pub App: _App,
    pub mbxdata: [u8; 1536usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _MBXh {
    pub length: u16,
    pub address: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _MBXh {
    #[inline]
    pub fn channel(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_channel(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn channel_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                6u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_channel_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn priority(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_priority(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn priority_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_priority_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mbxtype(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_mbxtype(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mbxtype_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mbxtype_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mbxcnt(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_mbxcnt(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mbxcnt_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mbxcnt_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        channel: u8,
        priority: u8,
        mbxtype: u8,
        mbxcnt: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let channel: u8 = unsafe { ::core::mem::transmute(channel) };
            channel as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let priority: u8 = unsafe { ::core::mem::transmute(priority) };
            priority as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let mbxtype: u8 = unsafe { ::core::mem::transmute(mbxtype) };
            mbxtype as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let mbxcnt: u8 = unsafe { ::core::mem::transmute(mbxcnt) };
            mbxcnt as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
pub struct _MBX {
    pub header: _MBXh,
    pub b: __IncompleteArrayField<u8>,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _COEh {
    pub numberservice: u16,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _INFOh {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub reserved: u8,
    pub fragmentsleft: u16,
}
impl _INFOh {
    #[inline]
    pub fn opcode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_opcode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn opcode_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                7u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_opcode_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn incomplete(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_incomplete(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn incomplete_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_incomplete_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(opcode: u8, incomplete: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let opcode: u8 = unsafe { ::core::mem::transmute(opcode) };
            opcode as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let incomplete: u8 = unsafe { ::core::mem::transmute(incomplete) };
            incomplete as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _MBXerr {
    pub mbxheader: _MBXh,
    pub type_: u16,
    pub detail: u16,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _COEsdo {
    pub mbxheader: _MBXh,
    pub coeheader: _COEh,
    pub command: u8,
    pub index: u16,
    pub subindex: u8,
    pub size: u32,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _COEobjdesc {
    pub mbxheader: _MBXh,
    pub coeheader: _COEh,
    pub infoheader: _INFOh,
    pub index: u16,
    pub datatype: u16,
    pub maxsub: u8,
    pub objectcode: u8,
    pub name: cty::c_char,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _COEentdesc {
    pub mbxheader: _MBXh,
    pub coeheader: _COEh,
    pub infoheader: _INFOh,
    pub index: u16,
    pub subindex: u8,
    pub valueinfo: u8,
    pub datatype: u16,
    pub bitlength: u16,
    pub access: u16,
    pub name: cty::c_char,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _FOEh {
    pub opcode: u8,
    pub reserved: u8,
    pub __bindgen_anon_1: _FOEh__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FOEh__bindgen_ty_1 {
    pub password: u32,
    pub packetnumber: u32,
    pub errorcode: u32,
}
#[repr(C, packed)]
pub struct _FOE {
    pub mbxheader: _MBXh,
    pub foeheader: _FOEh,
    pub __bindgen_anon_1: _FOE__bindgen_ty_1,
}
#[repr(C)]
pub struct _FOE__bindgen_ty_1 {
    pub filename: __BindgenUnionField<[cty::c_char; 0usize]>,
    pub data: __BindgenUnionField<[u8; 0usize]>,
    pub errortext: __BindgenUnionField<[cty::c_char; 0usize]>,
    pub bindgen_union_field: [u8; 0usize],
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _EOEh {
    pub frameinfo1: u16,
    pub __bindgen_anon_1: _EOEh__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EOEh__bindgen_ty_1 {
    pub frameinfo2: u16,
    pub result: u16,
}
#[repr(C, packed)]
pub struct _EOE {
    pub mbxheader: _MBXh,
    pub eoeheader: _EOEh,
    pub data: __IncompleteArrayField<u8>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MBXcontrol {
    pub state: u8,
}
unsafe extern "C" {
    pub fn ESC_config(cfg: *mut esc_cfg_t);
}
unsafe extern "C" {
    pub fn ESC_ALerror(errornumber: u16);
}
unsafe extern "C" {
    pub fn ESC_ALeventwrite(event: u32);
}
unsafe extern "C" {
    pub fn ESC_ALeventread() -> u32;
}
unsafe extern "C" {
    pub fn ESC_ALeventmaskwrite(mask: u32);
}
unsafe extern "C" {
    pub fn ESC_ALeventmaskread() -> u32;
}
unsafe extern "C" {
    pub fn ESC_ALstatus(status: u8);
}
unsafe extern "C" {
    pub fn ESC_ALstatusgotoerror(status: u8, errornumber: u16);
}
unsafe extern "C" {
    pub fn ESC_SMstatus(n: u8);
}
unsafe extern "C" {
    pub fn ESC_WDstatus() -> u8;
}
unsafe extern "C" {
    pub fn ESC_claimbuffer() -> u8;
}
unsafe extern "C" {
    pub fn ESC_startmbx(state: u8) -> u8;
}
unsafe extern "C" {
    pub fn ESC_stopmbx();
}
unsafe extern "C" {
    pub fn MBX_error(error: u16);
}
unsafe extern "C" {
    pub fn ESC_mbxprocess() -> u8;
}
unsafe extern "C" {
    pub fn ESC_xoeprocess();
}
unsafe extern "C" {
    pub fn ESC_startinput(state: u8) -> u8;
}
unsafe extern "C" {
    pub fn ESC_stopinput();
}
unsafe extern "C" {
    pub fn ESC_startoutput(state: u8) -> u8;
}
unsafe extern "C" {
    pub fn ESC_stopoutput();
}
unsafe extern "C" {
    pub fn ESC_state();
}
unsafe extern "C" {
    pub fn ESC_sm_act_event();
}
unsafe extern "C" {
    pub fn ESC_read(address: u16, buf: *mut cty::c_void, len: u16);
}
unsafe extern "C" {
    pub fn ESC_write(address: u16, buf: *mut cty::c_void, len: u16);
}
unsafe extern "C" {
    pub fn ESC_init(cfg: *const esc_cfg_t);
}
unsafe extern "C" {
    pub fn ESC_reset();
}
unsafe extern "C" {
    pub fn APP_safeoutput();
}
unsafe extern "C" {
    pub static mut ESCvar: _ESCvar;
}
unsafe extern "C" {
    pub static mut MBXcontrol: [_MBXcontrol; 0usize];
}
unsafe extern "C" {
    pub static mut MBX: [u8; 0usize];
}
unsafe extern "C" {
    pub static mut SMmap2: [_SMmap; 0usize];
}
unsafe extern "C" {
    pub static mut SMmap3: [_SMmap; 0usize];
}
